<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>STAR DRIFT: NETLINK</title>
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body {
            margin: 0;
            background: #222222;
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .font-loader {
            position: absolute;
            opacity: 0;
            font-family: 'Chakra Petch';
            font-weight: 700;
        }

        #lobby-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }

        input {
            font-family: 'Chakra Petch';
            font-size: 24px;
            padding: 10px;
            text-align: center;
            text-transform: uppercase;
            background: #000;
            color: #0088ff;
            border: 2px solid #0088ff;
            margin-bottom: 20px;
            pointer-events: auto;
        }

        #rules-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
        }

        .modal-content {
            background: #222;
            border: 2px solid #0088ff;
            padding: 20px;
            max-width: 80%;
            text-align: center;
            font-family: 'Chakra Petch';
            color: #fff;
            box-shadow: 0 0 20px #0088ff;
        }

        .modal-content h2 {
            color: #0088ff;
            margin-top: 0;
        }

        .modal-content p {
            font-size: 14px;
            line-height: 1.5;
            margin: 10px 0;
        }

        .modal-content button {
            background: #004400;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-family: 'Chakra Petch';
            font-size: 18px;
            cursor: pointer;
            margin-top: 10px;
            border: 1px solid #00ff88;
        }

        .modal-content button:hover {
            background: #006600;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
</head>

<body>

    <div class="font-loader">.</div>

    <div id="lobby-ui">
        <input type="text" id="join-code" maxlength="3" placeholder="ENTER 3-CHAR CODE">
    </div>

    <div id="rules-modal">
        <div class="modal-content">
            <h2>GAME RULES</h2>
            <p>Swipe on the screen to move.</p>
            <p id="rule-win-score">Collect 50 points of rocks to win.</p>
            <p id="rule-points" style="text-align: left; display: inline-block;">
                Small = 1pt<br>
                Medium = 2pts<br>
                Big = 5pts
            </p>
            <p id="rule-collision">When ships collide, the faster one was reckless,<br>so the slower one gets 3pts.</p>
            <button id="close-rules">CLOSE</button>
        </div>
    </div>

    <script>
        // --- GLOBAL CONFIG ---
        const LOGICAL_WIDTH = 540;
        const LOGICAL_HEIGHT = 960;
        const ZONE_SIZE = 200;

        const CONFIG = {
            GAME: {
                WIN_SCORE: 50, // Score to win
                ASTEROID_SPAWN_DELAY: 2000,
                COLLISION_REWARD: 3,
                COLLISION_BLAST_FORCE: 800,
                COLLISION_COOLDOWN: 500
            },
            SHIP: {
                MAX_SPEED: 400,
                MAX_ACCEL_AI: 1500, // Default AI Accel limit (will be overridden by difficulty/logic)
                MAX_ACCEL_AI_BOOST: 3000, // The boosted accel we added
                DRAG: 0.5,
                BOUNCE: 0.9,
                INPUT_IMPULSE: 5,
                RADIUS: 30, // Physics radius (note: we used 20 before resizing visuals, but setCircle(30) in code. Let's make this 30)
                RADIUS_COLLIDER: 30
            },
            ASTEROID: {
                SPEED_MIN: 50,
                SPEED_MAX: 150,
                GROWTH_DELAY_MIN: 3000,
                GROWTH_DELAY_MAX: 6000,
                POINTS: { SMALL: 1, MED: 2, BIG: 5 },
                RADIUS: { SMALL: 12, MED: 22, BIG: 45 },
                STAGES: ['asteroid_small', 'asteroid_med', 'asteroid_large']
            },
            AI: {
                // Behavioral Weights
                BASE_GREED: 1.0,
                BASE_AGGRESSION: 0.1,

                // Losing/Winning Adjustments
                LOSING_AGGRESSION: 2.0, // Was hardcoded as 2.0 in update
                LOSING_GREED: 0.1,
                WINNING_AGGRESSION: 0.0,
                WINNING_GREED: 1.0,

                // Distances
                COMBAT_DISTANCE: 250, // Was 250/200 in various checks
                ATTACK_RANGE: 200,

                // Priority Scores
                SCORE_EVADE_CRITICAL: 100000, // Evade when faster
                SCORE_INTERCEPT_BASE: 2000, // Base intercept
                SCORE_INTERCEPT_HUNT: 10000, // Hyper aggressive hunt
                SCORE_SAFE_EVADE: 5000, // Evade when winning

                // Rock Priorities
                SCORE_ROCK_BIG: 3000,
                SCORE_ROCK_MED_CLOSE: 2500
            }
        };

        // --- NETWORK MANAGER ---
        class NetworkMgr {
            constructor() {
                this.peer = null;
                this.conn = null;
                this.role = 'offline';
                this.myId = '';
                this.onData = null;
                this.onConnect = null;
            }

            init(id = null) {
                const peerId = id ? `sd-${id}` : null;
                this.peer = new Peer(peerId);

                this.peer.on('open', (id) => {
                    this.myId = id.replace('sd-', '');
                    console.log('My ID:', this.myId);
                });

                this.peer.on('connection', (conn) => {
                    if (this.conn) { conn.close(); return; }
                    this.conn = conn;
                    this.setupConnEvents();
                    if (this.onConnect) this.onConnect();
                });

                this.peer.on('error', (err) => console.error(err));
            }

            connect(hostId) {
                this.conn = this.peer.connect(`sd-${hostId}`);
                this.setupConnEvents();
            }

            setupConnEvents() {
                this.conn.on('open', () => {
                    console.log('Connected to peer');
                    if (this.role === 'client' && this.onConnect) this.onConnect();
                });
                this.conn.on('data', (data) => {
                    if (this.onData) this.onData(data);
                });
                this.conn.on('close', () => {
                    console.log('Connection closed');
                    window.location.reload();
                });
            }

            send(data) {
                if (this.conn && this.conn.open) {
                    this.conn.send(data);
                }
            }
        }

        const net = new NetworkMgr();

        // --- AI CONTROLLER ---
        class BotController {
            constructor(scene, ship, opponent, asteroids) {
                this.scene = scene;
                this.ship = ship;
                this.opponent = opponent;
                this.asteroids = asteroids;
                this.asteroids = asteroids;
                this.baseWeights = { greed: CONFIG.AI.BASE_GREED, aggression: CONFIG.AI.BASE_AGGRESSION };
                this.currentWeights = { ...this.baseWeights };
                this.MAX_ACCEL = CONFIG.SHIP.MAX_ACCEL_AI_BOOST;
            }

            update() {
                // 0. RESET WEIGHTS & SAFE START CHECK
                this.currentWeights = { ...this.baseWeights };
                const asteroidCount = this.asteroids.countActive();

                // FIX 1: RECKLESS START PREVENTION
                // If there are no asteroids, force aggression to 0 so we don't ram randomly.
                if (asteroidCount === 0) {
                    this.currentWeights.aggression = 0.0;
                }

                // 1. SCORE ADAPTATION
                const myScore = this.scene.score2;
                const pScore = this.scene.score1;
                const scoreDiff = myScore - pScore;

                if (myScore < pScore) {
                    // We are losing. We want to collide.
                    this.currentWeights.aggression = CONFIG.AI.LOSING_AGGRESSION;
                    this.currentWeights.greed = CONFIG.AI.LOSING_GREED;
                } else {
                    // We are winning or tied. Avoid collision.
                    this.currentWeights.aggression = CONFIG.AI.WINNING_AGGRESSION;
                    this.currentWeights.greed = CONFIG.AI.WINNING_GREED;
                }

                const desires = [];
                const pSpeed = this.opponent.body.speed;
                const mySpeed = this.ship.body.speed;
                const distToPlayer = this.getToroidalDistance(this.ship.x, this.ship.y, this.opponent.x, this.opponent.y);

                // --- CRITICAL SAFETY OVERRIDE ---
                let speedLimit = CONFIG.SHIP.MAX_SPEED;
                if (distToPlayer < CONFIG.AI.COMBAT_DISTANCE) {
                    if (mySpeed > pSpeed) { speedLimit = Math.max(0, pSpeed - 30); }
                }

                // --- BEHAVIOR 1: COLLISION LOGIC ---
                // Only fight if we are losing or it's a guaranteed win
                // Added Check: asteroidCount > 0. Don't fight if the game just started (empty space).
                if (asteroidCount > 0 && distToPlayer < 140 && this.isMovingTowards(this.ship, this.opponent)) {
                    if (mySpeed > pSpeed) {
                        desires.push({ type: 'EVADE', score: 100000, target: this.opponent });
                    } else {
                        // 1. Check Intercept (Base Priority)
                        // Only if close enough to matter
                        if (distToPlayer < CONFIG.AI.COMBAT_DISTANCE) {
                            desires.push({
                                type: 'INTERCEPT', score: CONFIG.AI.SCORE_INTERCEPT_BASE, target: this.opponent,
                                desiredSpeed: this.MAX_ACCEL, position: { x: this.opponent.x, y: this.opponent.y }
                            });
                        } else {
                            // If too far, lightly desire to get closer (lower score)
                            desires.push({
                                type: 'INTERCEPT', score: 500, target: this.opponent,
                                desiredSpeed: this.MAX_ACCEL, position: { x: this.opponent.x, y: this.opponent.y }
                            });
                        }
                    }
                } else if (asteroidCount === 0 && distToPlayer < 200) {
                    // Safe start evasion
                    desires.push({ type: 'EVADE', score: 500, target: this.opponent });
                }

                // --- BEHAVIOR 2: HUNT ROCKS ---
                this.asteroids.getChildren().forEach(rock => {
                    if (!rock.active) return;

                    const rawDist = Phaser.Math.Distance.Between(this.ship.x, this.ship.y, rock.x, rock.y);
                    const timeToHit = rawDist / 200;
                    let futureRockX = rock.x + (rock.body.velocity.x * timeToHit);
                    let futureRockY = rock.y + (rock.body.velocity.y * timeToHit);

                    const w = this.scene.scale.width; const h = this.scene.scale.height;
                    if (futureRockX < 0) futureRockX += w; if (futureRockX > w) futureRockX -= w;
                    if (futureRockY < 0) futureRockY += h; if (futureRockY > h) futureRockY -= h;

                    const dist = this.getToroidalDistance(this.ship.x, this.ship.y, futureRockX, futureRockY);

                    // FIX 2: CONTESTED ROCK LOGIC
                    // Calculate Player's distance to this specific rock
                    const playerDistToRock = this.getToroidalDistance(this.opponent.x, this.opponent.y, futureRockX, futureRockY);

                    // Denial Multiplier: If player is closer to the rock than me (or it's a tight race),
                    // dramatically increase the value of this rock so I steal it.
                    let denialMult = 1.0;
                    // If player is closer OR roughly same distance (1.2 buffer)
                    if (playerDistToRock < dist * 1.2) {
                        denialMult = 5.0; // High priority to deny
                    }

                    // MOMENTUM CHECK
                    let angleCost = 0;
                    if (this.ship.body.speed > 50) {
                        const angleToTarget = Phaser.Math.Angle.Between(this.ship.x, this.ship.y, futureRockX, futureRockY);
                        const currentAngle = this.ship.body.velocity.angle();
                        let diff = Math.abs(Phaser.Math.Angle.Wrap(angleToTarget - currentAngle));
                        angleCost = diff * 150;
                    }

                    let score = 0;
                    // PRIORITY 1: Big Rocks (Any distance)
                    if (rock.points >= CONFIG.ASTEROID.POINTS.BIG) {
                        score = CONFIG.AI.SCORE_ROCK_BIG;
                    }
                    // PRIORITY 2: Medium Rocks (Close)
                    else if (rock.points >= CONFIG.ASTEROID.POINTS.MED && dist < CONFIG.AI.ATTACK_RANGE) {
                        score = CONFIG.AI.SCORE_ROCK_MED_CLOSE;
                    }
                    // Default scoring for other rocks
                    else {
                        let value = Math.pow(rock.points, 3);
                        score = ((value * 2000 * denialMult) / (dist + angleCost + 10));
                    }
                    score *= this.currentWeights.greed;

                    desires.push({
                        type: 'COLLECT', target: rock, score: score,
                        position: { x: futureRockX, y: futureRockY },
                        isBig: rock.points >= CONFIG.ASTEROID.POINTS.BIG
                    });
                });

                // --- BEHAVIOR 3: CENTER CONTROL ---
                desires.push({
                    type: 'CENTER', score: 50,
                    position: { x: this.scene.scale.width / 2, y: this.scene.scale.height / 2 }
                });

                // --- EXECUTE ---
                desires.sort((a, b) => b.score - a.score);
                const bestDesire = desires[0];

                if (bestDesire.type === 'EVADE') {
                    const angleToOpponent = Phaser.Math.Angle.Between(this.ship.x, this.ship.y, this.opponent.x, this.opponent.y);
                    this.scene.physics.velocityFromRotation(angleToOpponent + 1.57, 400, this.ship.body.acceleration);
                }
                else if (bestDesire.type === 'COLLECT' || bestDesire.type === 'CENTER') {
                    const limit = bestDesire.isBig ? 400 : speedLimit;
                    this.applySteeringForce(bestDesire.position.x, bestDesire.position.y, limit);
                }
                else if (bestDesire.type === 'INTERCEPT') {
                    this.applySteeringForce(bestDesire.position.x, bestDesire.position.y, bestDesire.desiredSpeed);
                }
            }

            applySteeringForce(tx, ty, maxSpeed) {
                const ship = this.ship;
                let targetX = tx; let targetY = ty;
                const w = this.scene.scale.width; const h = this.scene.scale.height;

                if (targetX - ship.x > w / 2) targetX -= w;
                else if (targetX - ship.x < -w / 2) targetX += w;
                if (targetY - ship.y > h / 2) targetY -= h;
                else if (targetY - ship.y < -h / 2) targetY += h;

                let desiredX = targetX - ship.x;
                let desiredY = targetY - ship.y;
                const length = Math.sqrt(desiredX * desiredX + desiredY * desiredY);
                if (length > 0) {
                    desiredX = (desiredX / length) * maxSpeed;
                    desiredY = (desiredY / length) * maxSpeed;
                }

                let steerX = desiredX - ship.body.velocity.x;
                let steerY = desiredY - ship.body.velocity.y;
                const steerLen = Math.sqrt(steerX * steerX + steerY * steerY);
                if (steerLen > this.MAX_ACCEL) {
                    steerX = (steerX / steerLen) * this.MAX_ACCEL;
                    steerY = (steerY / steerLen) * this.MAX_ACCEL;
                }

                ship.setAcceleration(steerX, steerY);
            }

            getToroidalDistance(x1, y1, x2, y2) {
                let dx = Math.abs(x1 - x2);
                let dy = Math.abs(y1 - y2);
                if (dx > this.scene.scale.width / 2) dx = this.scene.scale.width - dx;
                if (dy > this.scene.scale.height / 2) dy = this.scene.scale.height - dy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            isMovingTowards(source, target) {
                const toTargetX = target.x - source.x;
                const toTargetY = target.y - source.y;
                return ((source.body.velocity.x * toTargetX) + (source.body.velocity.y * toTargetY)) > 0;
            }
        }

        // --- SCENE 1: MAIN MENU ---
        class MainMenu extends Phaser.Scene {
            constructor() { super({ key: 'MainMenu' }); }

            create() {
                const w = this.scale.width;
                const h = this.scale.height;

                document.getElementById('lobby-ui').style.display = 'none';

                const border = this.add.graphics();
                border.lineStyle(4, 0x333333);
                border.strokeRect(0, 0, w, h);

                this.add.text(w / 2, h * 0.15, 'STAR DRIFT', {
                    fontFamily: 'Chakra Petch', fontSize: '60px', fontWeight: '900', color: '#ffffff'
                }).setOrigin(0.5);

                const btnY = (offset) => h * 0.4 + (offset * 80);

                this.createButton(w / 2, btnY(0), '1 PLAYER (VS AI)', 0xff0044, () => {
                    net.role = 'offline';
                    this.scene.start('GameScene');
                });

                this.createButton(w / 2, btnY(1), 'START 2-P GAME', 0x0088ff, () => {
                    this.startHostSequence();
                });

                this.createButton(w / 2, btnY(2), 'JOIN 2-P GAME', 0x00ff88, () => {
                    this.startJoinSequence();
                });

                this.createButton(w / 2, btnY(3), 'RULES', 0xffaa00, () => {
                    document.getElementById('rules-modal').style.display = 'flex';
                });

                document.getElementById('close-rules').onclick = () => {
                    document.getElementById('rules-modal').style.display = 'none';
                };
            }

            createButton(x, y, text, color, callback) {
                const btn = this.add.text(x, y, text, {
                    fontFamily: 'Chakra Petch', fontSize: '30px', fontWeight: 'bold', color: '#ffffff',
                    backgroundColor: '#222222', padding: { x: 20, y: 10 }
                }).setOrigin(0.5).setInteractive();
                btn.on('pointerdown', callback);
            }

            startHostSequence() {
                const code = Math.random().toString(36).substring(2, 5).toUpperCase();
                net.role = 'host';
                net.init(code);

                const w = this.scale.width; const h = this.scale.height;
                const bg = this.add.rectangle(w / 2, h / 2, w, h, 0x000000, 0.9).setInteractive();

                const txt = this.add.text(w / 2, h / 2 - 40, `WAITING FOR P2...\n\nCODE: ${code}`, {
                    fontFamily: 'Chakra Petch', fontSize: '30px', align: 'center', color: '#0088ff'
                }).setOrigin(0.5);

                this.add.text(w / 2, h / 2 + 50, 'SHARE THIS CODE WITH YOUR FRIEND', {
                    fontFamily: 'Chakra Petch', fontSize: '16px', color: '#888888'
                }).setOrigin(0.5);

                const cancelBtn = this.add.text(w / 2, h * 0.8, 'CANCEL', {
                    fontFamily: 'Chakra Petch', fontSize: '24px', color: '#ff4444'
                }).setOrigin(0.5).setInteractive();

                cancelBtn.on('pointerdown', () => {
                    if (net.peer) net.peer.destroy();
                    window.location.reload();
                });

                net.onConnect = () => {
                    this.scene.start('GameScene');
                };
            }

            startJoinSequence() {
                net.role = 'client';
                net.init();

                const w = this.scale.width; const h = this.scale.height;
                const bg = this.add.rectangle(w / 2, h / 2, w, h, 0x000000, 0.9).setInteractive();

                const ui = document.getElementById('lobby-ui');
                ui.style.display = 'flex';
                const input = document.getElementById('join-code');
                input.value = '';
                input.focus();

                this.add.text(w / 2, h * 0.3, 'ENTER HOST CODE:', {
                    fontFamily: 'Chakra Petch', fontSize: '24px', color: '#00ff88'
                }).setOrigin(0.5);

                const goBtn = this.add.text(w / 2, h * 0.6, '[ CONNECT ]', {
                    fontFamily: 'Chakra Petch', fontSize: '30px', color: '#ffffff', backgroundColor: '#004400', padding: 10
                }).setOrigin(0.5).setInteractive();

                goBtn.on('pointerdown', () => {
                    const code = input.value.toUpperCase();
                    if (code.length === 3) {
                        ui.style.display = 'none';
                        txt.setText("CONNECTING...");
                        net.connect(code);
                    }
                });

                const txt = this.add.text(w / 2, h * 0.5, '', { fontFamily: 'Chakra Petch', fontSize: '20px' }).setOrigin(0.5);

                net.onConnect = () => {
                    this.scene.start('GameScene');
                };
            }
        }

        // --- SCENE 2: THE GAME ---
        class GameScene extends Phaser.Scene {
            constructor() { super({ key: 'GameScene' }); }

            create() {
                this.score1 = 0; this.score2 = 0; this.isGameOver = false;

                this.generateTextures();
                this.particles = this.add.particles(0, 0, 'spark', {
                    speed: { min: 50, max: 150 }, scale: { start: 1, end: 0 },
                    blendMode: 'ADD', lifespan: 300, emitting: false
                });

                this.setupShips();
                this.asteroids = this.physics.add.group({ classType: Asteroid, runChildUpdate: true });

                if (net.role !== 'client') {
                    this.spawnEvent = this.time.addEvent({
                        delay: CONFIG.GAME.ASTEROID_SPAWN_DELAY, callback: this.spawnAsteroid, callbackScope: this, loop: true
                    });
                }

                this.setupUI();

                if (net.role !== 'client') {
                    this.setupCollisions();
                    if (net.role === 'offline') {
                        this.bot = new BotController(this, this.ship2, this.ship1, this.asteroids);
                        this.scoreText2.setText('CPU: 0');
                    } else {
                        this.scoreText2.setText('P2: 0');
                    }
                } else {
                    this.scoreText2.setText('P2: 0');
                    this.ship1.body.moves = false;
                    this.ship2.body.moves = false;
                }

                this.input.on('pointerup', (pointer) => this.handleInput(pointer));
                net.onData = (data) => this.handleNetworkData(data);
            }

            update() {
                if (this.isGameOver) return;

                if (net.role === 'client') return;

                this.physics.world.wrap(this.ship1, 20);
                this.physics.world.wrap(this.ship2, 20);
                this.physics.world.wrap(this.asteroids, 60);

                if (this.bot) this.bot.update();

                if (net.role === 'host') {
                    this.broadcastState();
                }
            }

            setupShips() {
                const p1StartX = ZONE_SIZE / 2;
                const p1StartY = this.scale.height - (ZONE_SIZE / 2);
                const p2StartX = this.scale.width - (ZONE_SIZE / 2);
                const p2StartY = ZONE_SIZE / 2;

                this.ship1 = this.physics.add.sprite(p1StartX, p1StartY, 'ship1_tex').setCircle(CONFIG.SHIP.RADIUS_COLLIDER);
                this.ship2 = this.physics.add.sprite(p2StartX, p2StartY, 'ship2_tex').setCircle(CONFIG.SHIP.RADIUS_COLLIDER);

                [this.ship1, this.ship2].forEach(s => {
                    s.setDamping(true); s.setDrag(CONFIG.SHIP.DRAG); s.setBounce(CONFIG.SHIP.BOUNCE); s.setMaxVelocity(CONFIG.SHIP.MAX_SPEED);
                });
            }

            setupCollisions() {
                this.physics.add.collider(this.ship1, this.ship2, this.handlePvpCollision, null, this);
                this.physics.add.overlap(this.ship1, this.asteroids, (s, a) => this.collectAsteroid(s, a, 1), null, this);
                this.physics.add.overlap(this.ship2, this.asteroids, (s, a) => this.collectAsteroid(s, a, 2), null, this);
            }

            setupUI() {
                const zg = this.add.graphics();
                zg.lineStyle(4, 0x333333);
                zg.strokeRect(0, 0, this.scale.width, this.scale.height);

                const fontStyle = { fontFamily: 'Chakra Petch', fontSize: '32px', fontWeight: 'bold' };
                this.scoreText1 = this.add.text(20, this.scale.height - 60, 'P1: 0', { ...fontStyle, color: '#ff0044' }).setDepth(100);
                this.scoreText2 = this.add.text(this.scale.width - 180, 30, 'P2: 0', { ...fontStyle, color: '#0088ff' }).setDepth(100);
            }

            handleInput(pointer) {
                if (this.isGameOver) return;
                const vectorX = pointer.upX - pointer.downX;
                const vectorY = pointer.upY - pointer.downY;
                if (Math.abs(vectorX) < 5 && Math.abs(vectorY) < 5) return;

                const IMPULSE = CONFIG.SHIP.INPUT_IMPULSE;

                if (net.role === 'offline') {
                    this.applyImpulse(this.ship1, vectorX, vectorY, IMPULSE);
                }
                else if (net.role === 'host') {
                    this.applyImpulse(this.ship1, vectorX, vectorY, IMPULSE);
                }
                else if (net.role === 'client') {
                    net.send({ type: 'INPUT', x: vectorX, y: vectorY });
                }
            }

            applyImpulse(ship, vx, vy, mult) {
                ship.setVelocity(ship.body.velocity.x + (vx * mult), ship.body.velocity.y + (vy * mult));
            }

            broadcastState() {
                const asteroidData = [];
                this.asteroids.getChildren().forEach(a => {
                    if (a.active) asteroidData.push({ x: Math.round(a.x), y: Math.round(a.y), t: a.texture.key });
                });

                const state = {
                    type: 'STATE',
                    s1: { x: Math.round(this.ship1.x), y: Math.round(this.ship1.y) },
                    s2: { x: Math.round(this.ship2.x), y: Math.round(this.ship2.y) },
                    sc1: this.score1,
                    sc2: this.score2,
                    as: asteroidData
                };
                net.send(state);
            }

            handleNetworkData(data) {
                if (net.role === 'host') {
                    if (data.type === 'INPUT') {
                        this.applyImpulse(this.ship2, data.x, data.y, 5);
                    }
                    else if (data.type === 'REMATCH_REQ') {
                        net.send({ type: 'RESTART' });
                        this.scene.restart();
                    }
                }
                else if (net.role === 'client') {
                    if (data.type === 'STATE') {
                        if (this.isGameOver) return;
                        this.ship1.setPosition(data.s1.x, data.s1.y);
                        this.ship2.setPosition(data.s2.x, data.s2.y);

                        this.score1 = data.sc1;
                        this.score2 = data.sc2;
                        this.scoreText1.setText('P1: ' + this.score1);
                        this.scoreText2.setText('P2: ' + this.score2);

                        const rocks = this.asteroids.getChildren();
                        rocks.forEach(r => { r.setVisible(false); r.setActive(false); });

                        data.as.forEach((d, index) => {
                            let rock = rocks[index];
                            if (!rock) {
                                rock = new Asteroid(this, d.x, d.y);
                                this.asteroids.add(rock);
                            }
                            rock.setPosition(d.x, d.y);
                            rock.setTexture(d.t);
                            rock.setVisible(true);
                            rock.setActive(true);
                        });
                    }
                    else if (data.type === 'GAME_OVER') {
                        this.score1 = data.sc1;
                        this.score2 = data.sc2;
                        this.doGameOver();
                    }
                    else if (data.type === 'RESTART') {
                        this.scene.restart();
                    }
                }
            }

            spawnAsteroid() {
                if (this.isGameOver) return;
                const edge = Phaser.Math.Between(0, 3);
                let x, y;
                const buffer = 60;
                const w = this.scale.width, h = this.scale.height;
                if (edge === 0) { x = Phaser.Math.Between(0, w); y = -buffer; }
                else if (edge === 1) { x = w + buffer; y = Phaser.Math.Between(0, h); }
                else if (edge === 2) { x = Phaser.Math.Between(0, w); y = h + buffer; }
                else { x = -buffer; y = Phaser.Math.Between(0, h); }
                const asteroid = new Asteroid(this, x, y);
                this.asteroids.add(asteroid);
                asteroid.launch(this);
            }

            collectAsteroid(ship, asteroid, playerNum) {
                if (this.isGameOver) return;
                const points = asteroid.points;
                if (playerNum === 1) {
                    this.score1 += points;
                    this.scoreText1.setText('P1: ' + this.score1);
                } else {
                    this.score2 += points;
                    this.scoreText2.setText((net.role === 'offline' ? 'CPU: ' : 'P2: ') + this.score2);
                }
                if (asteroid.growthTimer) asteroid.growthTimer.remove();
                asteroid.destroy();
                this.checkWin();
            }

            handlePvpCollision(s1, s2) {
                if (this.isGameOver) return;
                // Add cooldown to prevent spamming collision points
                const now = this.time.now;
                if (this.lastCollisionTime && now - this.lastCollisionTime < CONFIG.GAME.COLLISION_COOLDOWN) return;
                this.lastCollisionTime = now;

                this.cameras.main.shake(200, 0.01);
                this.particles.emitParticleAt((s1.x + s2.x) / 2, (s1.y + s2.y) / 2, 10);

                // FORCE BLAST - Explicitly separate ships
                const angle = Phaser.Math.Angle.Between(s1.x, s1.y, s2.x, s2.y);
                // S1 goes opposite to angle
                s1.setVelocity(Math.cos(angle + Math.PI) * CONFIG.GAME.COLLISION_BLAST_FORCE, Math.sin(angle + Math.PI) * CONFIG.GAME.COLLISION_BLAST_FORCE);
                // S2 goes with angle
                s2.setVelocity(Math.cos(angle) * CONFIG.GAME.COLLISION_BLAST_FORCE, Math.sin(angle) * CONFIG.GAME.COLLISION_BLAST_FORCE);

                const REWARD = CONFIG.GAME.COLLISION_REWARD;
                const speed1 = s1.body.speed;
                const speed2 = s2.body.speed;
                //  if (Math.abs(speed1 - speed2) < 2) return;

                if (speed1 > speed2) {
                    this.score2 += REWARD;
                    this.scoreText2.setText((net.role === 'offline' ? 'CPU: ' : 'P2: ') + this.score2);
                    s2.setTint(0x00ff00); this.time.delayedCall(200, () => s2.clearTint());
                } else {
                    this.score1 += REWARD;
                    this.scoreText1.setText('P1: ' + this.score1);
                    s1.setTint(0x00ff00); this.time.delayedCall(200, () => s1.clearTint());
                }
                this.checkWin();
            }

            checkWin() {
                if (this.isGameOver) return;
                if (this.score1 >= CONFIG.GAME.WIN_SCORE || this.score2 >= CONFIG.GAME.WIN_SCORE) {
                    if (net.role === 'host') {
                        net.send({ type: 'GAME_OVER', sc1: this.score1, sc2: this.score2 });
                    }
                    this.doGameOver();
                }
            }

            doGameOver() {
                this.isGameOver = true;
                this.physics.pause();

                this.scoreText1.setText('P1: ' + this.score1);
                this.scoreText2.setText((net.role === 'offline' ? 'CPU: ' : 'P2: ') + this.score2);

                const overlay = this.add.rectangle(this.scale.width / 2, this.scale.height / 2, this.scale.width, this.scale.height, 0x000000, 0.8);
                overlay.setDepth(200);

                let winner = "";
                if (this.score1 >= CONFIG.GAME.WIN_SCORE) winner = "PLAYER 1";
                else winner = net.role === 'offline' ? "CPU" : "PLAYER 2";

                const color = this.score1 >= CONFIG.GAME.WIN_SCORE ? "#ff0044" : "#0088ff";
                this.add.text(this.scale.width / 2, this.scale.height / 2 - 50, `${winner} WINS!`, {
                    fontFamily: 'Chakra Petch', fontSize: '50px', fontWeight: '900', color: color, stroke: '#ffffff', strokeThickness: 2
                }).setOrigin(0.5).setDepth(201);

                const restartBtn = this.add.text(this.scale.width / 2, this.scale.height / 2 + 60, 'PLAY AGAIN', {
                    fontFamily: 'Chakra Petch', fontSize: '30px', backgroundColor: '#006600', padding: { x: 20, y: 10 }
                }).setOrigin(0.5).setDepth(201).setInteractive();

                restartBtn.on('pointerdown', () => {
                    if (net.role === 'host') {
                        net.send({ type: 'RESTART' });
                        this.scene.restart();
                    } else if (net.role === 'client') {
                        net.send({ type: 'REMATCH_REQ' });
                        restartBtn.setText("WAITING...");
                        restartBtn.setBackgroundColor('#333333');
                    } else {
                        this.scene.restart();
                    }
                });

                const menuBtn = this.add.text(this.scale.width / 2, this.scale.height / 2 + 140, 'MAIN MENU', {
                    fontFamily: 'Chakra Petch', fontSize: '30px', backgroundColor: '#333', padding: { x: 20, y: 10 }
                }).setOrigin(0.5).setDepth(201).setInteractive();

                menuBtn.on('pointerdown', () => {
                    if (net.conn) net.conn.close();
                    window.location.reload();
                });
            }

            generateTextures() {
                if (this.textures.exists('ship1_tex')) return;

                const g1 = this.make.graphics();
                g1.lineStyle(2, 0xffffff); g1.fillStyle(0xff0044);
                g1.fillCircle(20, 20, 19); g1.strokeCircle(20, 20, 19);
                g1.fillStyle(0xffff00); g1.fillCircle(20, 20, 6);
                g1.generateTexture('ship1_tex', 40, 40);

                const g2 = this.make.graphics();
                g2.lineStyle(2, 0xffffff); g2.fillStyle(0x0088ff);
                g2.fillCircle(20, 20, 19); g2.strokeCircle(20, 20, 19);
                g2.lineStyle(3, 0x000000);
                g2.beginPath(); g2.moveTo(12, 12); g2.lineTo(28, 28); g2.moveTo(28, 12); g2.lineTo(12, 28); g2.strokePath();
                g2.generateTexture('ship2_tex', 40, 40);

                [['asteroid_small', 0x888888, 12], ['asteroid_med', 0xaaaaaa, 22], ['asteroid_large', 0xcccccc, 45]].forEach(data => {
                    const g = this.make.graphics(); g.fillStyle(data[1]);
                    const points = [];
                    for (let i = 0; i < 8; i++) {
                        const a = (i / 8) * (Math.PI * 2); const r = data[2] * Phaser.Math.FloatBetween(0.8, 1.2);
                        points.push({ x: data[2] + Math.cos(a) * r, y: data[2] + Math.sin(a) * r });
                    }
                    g.fillPoints(points, true); g.generateTexture(data[0], data[2] * 2.5, data[2] * 2.5);
                });

                const gs = this.make.graphics(); gs.fillStyle(0xffffff); gs.fillCircle(4, 4, 4); gs.generateTexture('spark', 8, 8);
            }
        }

        class Asteroid extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, 'asteroid_small');
                scene.add.existing(this); scene.physics.add.existing(this);
                this.stage = 1; this.points = CONFIG.ASTEROID.POINTS.SMALL; this.body.setBounce(1); this.body.setCircle(CONFIG.ASTEROID.RADIUS.SMALL);
            }
            launch(scene) {
                const tx = Phaser.Math.Between(scene.scale.width * 0.2, scene.scale.width * 0.8);
                const ty = Phaser.Math.Between(scene.scale.height * 0.2, scene.scale.height * 0.8);
                const angle = Phaser.Math.Angle.Between(this.x, this.y, tx, ty);
                scene.physics.velocityFromRotation(angle, Phaser.Math.Between(CONFIG.ASTEROID.SPEED_MIN, CONFIG.ASTEROID.SPEED_MAX), this.body.velocity);
                this.setAngularVelocity(Phaser.Math.Between(-20, 20));
                this.setNextGrowth(scene);
            }
            setNextGrowth(scene) {
                if (this.stage >= 3) return;
                this.growthTimer = scene.time.delayedCall(Phaser.Math.Between(CONFIG.ASTEROID.GROWTH_DELAY_MIN, CONFIG.ASTEROID.GROWTH_DELAY_MAX), () => this.grow());
            }
            grow() {
                // FIX 3: STOP GROWING IF GAME IS OVER
                if (!this.scene || !this.active || this.scene.isGameOver) return;

                this.scene.tweens.add({
                    targets: this, scaleX: 0.1, scaleY: 0.1, duration: 200, ease: 'Back.In',
                    onComplete: () => {
                        if (!this.scene || !this.active || this.scene.isGameOver) return;
                        this.stage++;
                        if (this.stage === 2) { this.setTexture('asteroid_med'); this.body.setCircle(CONFIG.ASTEROID.RADIUS.MED); this.points = CONFIG.ASTEROID.POINTS.MED; }
                        else if (this.stage === 3) { this.setTexture('asteroid_large'); this.body.setCircle(CONFIG.ASTEROID.RADIUS.BIG); this.points = CONFIG.ASTEROID.POINTS.BIG; }
                        this.scene.tweens.add({ targets: this, scaleX: 1, scaleY: 1, duration: 400, ease: 'Back.Out' });
                        this.setNextGrowth(this.scene);
                    }
                });
            }
        }

        const config = {
            type: Phaser.AUTO,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: LOGICAL_WIDTH,
                height: LOGICAL_HEIGHT
            },
            backgroundColor: '#000000', pixelArt: true,
            physics: { default: 'arcade', arcade: { gravity: { x: 0, y: 0 }, debug: false } },
            scene: [MainMenu, GameScene]
        };

        const game = new Phaser.Game(config);

        // --- DYNAMIC UI UPDATES ---
        function updateRulesUI() {
            document.getElementById('rule-win-score').innerText = `Collect ${CONFIG.GAME.WIN_SCORE} points of rocks to win.`;
            document.getElementById('rule-points').innerHTML = `
                Small = ${CONFIG.ASTEROID.POINTS.SMALL}pt<br>
                Medium = ${CONFIG.ASTEROID.POINTS.MED}pts<br>
                Big = ${CONFIG.ASTEROID.POINTS.BIG}pts
            `;
            document.getElementById('rule-collision').innerHTML = `When ships collide, the faster one was reckless,<br>so the slower one gets ${CONFIG.GAME.COLLISION_REWARD}pts.`;
        }
        updateRulesUI();
    </script>

</body>

</html>