<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>STAR DRIFT 0.6.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            background: #000000;
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }

        /* Center the canvas for tablets */
        .font-loader {
            position: absolute;
            opacity: 0;
            font-family: 'Orbitron';
            font-weight: 700;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
</head>

<body>

    <div class="font-loader">.</div>

    <script>
        // --- GLOBAL CONFIG ---
        // FIXED RESOLUTION: This forces the game to always look like a phone app
        // regardless of the device. Tablets will show black bars on sides.
        const LOGICAL_WIDTH = 540;
        const LOGICAL_HEIGHT = 960;

        const ZONE_SIZE = 200;
        const WIN_SCORE = 30;

        // --- AI CONTROLLER CLASS ---
        class BotController {
            constructor(scene, ship, opponent, asteroids) {
                this.scene = scene;
                this.ship = ship;
                this.opponent = opponent;
                this.asteroids = asteroids;

                // 1. DEFAULTS: High Greed, Low Aggression/Patience
                this.weights = {
                    greed: 1.0,
                    aggression: 0.1,
                    patience: 0.1
                };

                this.MAX_ACCEL = 600;

                // 2. DYNAMIC PERSONALITY
                this.scene.time.addEvent({
                    delay: 10000,
                    callback: this.evolvePersonality,
                    callbackScope: this,
                    loop: true
                });
            }

            evolvePersonality() {
                const drift = () => Phaser.Math.FloatBetween(-0.1, 0.1);
                this.weights.greed = Phaser.Math.Clamp(this.weights.greed + drift(), 0.5, 1.0);
                this.weights.aggression = Phaser.Math.Clamp(this.weights.aggression + drift(), 0.0, 0.4);
                this.weights.patience = Phaser.Math.Clamp(this.weights.patience + drift(), 0.0, 0.3);
            }

            update() {
                const desires = [];
                const pSpeed = this.opponent.body.speed;
                const mySpeed = this.ship.body.speed;
                const distToPlayer = this.getToroidalDistance(this.ship.x, this.ship.y, this.opponent.x, this.opponent.y);

                // --- 1. COLLISION LOGIC (The "Danger Zone") ---
                // REDUCED RADIUS: Was 250, now 140. 
                // The AI will only engage in combat if you are genuinely close.
                if (distToPlayer < 140 && this.isMovingTowards(this.ship, this.opponent)) {
                    if (mySpeed > pSpeed) {
                        const closingSpeed = mySpeed + pSpeed;
                        const timeToImpact = distToPlayer / closingSpeed;
                        const speedDiff = mySpeed - pSpeed;
                        const timeToBrake = (speedDiff + 50) / this.MAX_ACCEL;

                        if (timeToBrake < timeToImpact) {
                            // Brake Trap: Only triggers if collision is imminent
                            desires.push({ type: 'BRAKE_TRAP', score: 50000, target: this.opponent });
                        } else {
                            // Evade: Too fast to stop
                            desires.push({ type: 'EVADE', score: 100000, target: this.opponent });
                        }
                    } else {
                        // Intercept: We are slower, so we want to hit you
                        let ramScore = 3000 * this.weights.aggression;
                        desires.push({
                            type: 'INTERCEPT', score: ramScore, target: this.opponent,
                            desiredSpeed: pSpeed - 10, position: { x: this.opponent.x, y: this.opponent.y }
                        });
                    }
                }

                // --- 2. HUNT ROCKS ---
                this.asteroids.getChildren().forEach(rock => {
                    if (!rock.active) return;

                    const rawDist = Phaser.Math.Distance.Between(this.ship.x, this.ship.y, rock.x, rock.y);
                    const timeToHit = rawDist / 200;
                    let futureRockX = rock.x + (rock.body.velocity.x * timeToHit);
                    let futureRockY = rock.y + (rock.body.velocity.y * timeToHit);

                    const w = this.scene.scale.width; const h = this.scene.scale.height;
                    if (futureRockX < 0) futureRockX += w; if (futureRockX > w) futureRockX -= w;
                    if (futureRockY < 0) futureRockY += h; if (futureRockY > h) futureRockY -= h;

                    const dist = this.getToroidalDistance(this.ship.x, this.ship.y, futureRockX, futureRockY);
                    const playerDist = this.getToroidalDistance(this.opponent.x, this.opponent.y, futureRockX, futureRockY);

                    let value = Math.pow(rock.points, 3);
                    // Theft Bonus: Only if we are fairly close (200px), not across the map
                    let theftBonus = (rock.points >= 5 && playerDist < dist && playerDist > 50 && dist < 200) ? 5000 : 0;
                    let score = ((value * 2000) / (dist + 10)) + theftBonus;

                    score *= this.weights.greed;

                    desires.push({
                        type: 'COLLECT', target: rock, score: score,
                        position: { x: futureRockX, y: futureRockY },
                        isBig: rock.points >= 5
                    });
                });

                // --- 3. OPPORTUNISTIC AGGRESSION ---
                // Long range harassment. Only triggers if we are far away (> 250).
                // This leaves a "Peace Zone" between 140px and 250px where rocks are the only priority.
                if (pSpeed > 150 && distToPlayer > 250) {
                    const projectionFactor = 0.6;
                    let interceptX = this.opponent.x + (this.opponent.body.velocity.x * projectionFactor);
                    let interceptY = this.opponent.y + (this.opponent.body.velocity.y * projectionFactor);
                    let attackScore = (pSpeed / (distToPlayer + 1)) * 100 * this.weights.aggression;

                    desires.push({
                        type: 'INTERCEPT', target: this.opponent, score: attackScore,
                        position: { x: interceptX, y: interceptY }, desiredSpeed: pSpeed - 20
                    });
                }

                // --- EXECUTE ---
                desires.sort((a, b) => b.score - a.score);
                const bestDesire = desires[0];

                if (!bestDesire || bestDesire.score < 10) {
                    this.applySteeringForce(this.scene.scale.width / 2, this.scene.scale.height / 2, 100);
                    return;
                }

                if (bestDesire.type === 'EVADE') {
                    const angleToOpponent = Phaser.Math.Angle.Between(this.ship.x, this.ship.y, this.opponent.x, this.opponent.y);
                    this.scene.physics.velocityFromRotation(angleToOpponent + Math.PI, 400, this.ship.body.acceleration);
                }
                else if (bestDesire.type === 'BRAKE_TRAP') {
                    const futureX = this.opponent.x + this.opponent.body.velocity.x * 0.2;
                    const futureY = this.opponent.y + this.opponent.body.velocity.y * 0.2;
                    this.applySteeringForce(futureX, futureY, 0);
                }
                else if (bestDesire.type === 'COLLECT') {
                    const speed = bestDesire.isBig ? 400 : 300;
                    this.applySteeringForce(bestDesire.position.x, bestDesire.position.y, speed);
                }
                else if (bestDesire.type === 'INTERCEPT') {
                    this.applySteeringForce(bestDesire.position.x, bestDesire.position.y, bestDesire.desiredSpeed);
                }
            }

            applySteeringForce(tx, ty, maxSpeed) {
                const ship = this.ship;
                let targetX = tx; let targetY = ty;
                const w = this.scene.scale.width; const h = this.scene.scale.height;

                if (targetX - ship.x > w / 2) targetX -= w;
                else if (targetX - ship.x < -w / 2) targetX += w;
                if (targetY - ship.y > h / 2) targetY -= h;
                else if (targetY - ship.y < -h / 2) targetY += h;

                let desiredX = targetX - ship.x;
                let desiredY = targetY - ship.y;
                const length = Math.sqrt(desiredX * desiredX + desiredY * desiredY);
                if (length > 0) {
                    desiredX = (desiredX / length) * maxSpeed;
                    desiredY = (desiredY / length) * maxSpeed;
                }

                let steerX = desiredX - ship.body.velocity.x;
                let steerY = desiredY - ship.body.velocity.y;
                const steerLen = Math.sqrt(steerX * steerX + steerY * steerY);
                if (steerLen > this.MAX_ACCEL) {
                    steerX = (steerX / steerLen) * this.MAX_ACCEL;
                    steerY = (steerY / steerLen) * this.MAX_ACCEL;
                }

                ship.setAcceleration(steerX, steerY);
            }

            getToroidalDistance(x1, y1, x2, y2) {
                let dx = Math.abs(x1 - x2);
                let dy = Math.abs(y1 - y2);
                if (dx > this.scene.scale.width / 2) dx = this.scene.scale.width - dx;
                if (dy > this.scene.scale.height / 2) dy = this.scene.scale.height - dy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            isMovingTowards(source, target) {
                const toTargetX = target.x - source.x;
                const toTargetY = target.y - source.y;
                return ((source.body.velocity.x * toTargetX) + (source.body.velocity.y * toTargetY)) > 0;
            }
        }

        // --- SCENE 1: MAIN MENU ---
        class MainMenu extends Phaser.Scene {
            constructor() { super({ key: 'MainMenu' }); }

            create() {
                // We use specific coordinates here because we know the exact size is 540x960
                const w = this.scale.width;
                const h = this.scale.height;

                this.add.graphics()
                    .fillStyle(0xffffff, 0.1).fillCircle(w * 0.2, h * 0.2, 2).fillCircle(w * 0.8, h * 0.8, 3)
                    .fillCircle(w * 0.1, h * 0.9, 1).fillCircle(w * 0.9, h * 0.1, 2);

                this.add.text(w / 2, h * 0.2, 'STAR DRIFT', {
                    fontFamily: 'Orbitron', fontSize: '60px', fontWeight: '900', color: '#ffffff'
                }).setOrigin(0.5);

                this.createButton(w / 2, h * 0.45, '1 PLAYER (VS AI)', 0xff0044, () => this.scene.start('GameScene', { isSinglePlayer: true }));
                this.createButton(w / 2, h * 0.55, '2 PLAYERS', 0x0088ff, () => this.scene.start('GameScene', { isSinglePlayer: false }));
                this.createButton(w / 2, h * 0.7, 'RULES', 0xaaaaaa, () => this.toggleRules(true));

                this.rulesContainer = this.add.container(0, 0);
                this.rulesContainer.setVisible(false).setDepth(200);

                const bg = this.add.rectangle(w / 2, h / 2, w, h, 0x000000, 0.9);
                const rulesText = `
MISSION:
Collect 30 points to win.

CONTROLS (1P):
Swipe Bottom Left to move.
AI controls Blue ship.

CONTROLS (2P):
P1: Swipe Bottom Left
P2: Swipe Top Right

SCORING:
Small Rock: 1 pt | Med: 2 pts | Lrg: 5 pts

COLLISIONS:
If ships crash, the FASTER ship was reckless.
The slower ship gets 3 points.
        `;

                const txt = this.add.text(w / 2, h / 2 - 50, rulesText, {
                    fontFamily: 'Orbitron', fontSize: '20px', color: '#ffffff', align: 'center', lineSpacing: 10
                }).setOrigin(0.5);

                const closeBtn = this.add.text(w / 2, h * 0.85, '[ CLOSE ]', {
                    fontFamily: 'Orbitron', fontSize: '30px', color: '#ff0044'
                }).setOrigin(0.5).setInteractive();

                closeBtn.on('pointerdown', () => this.toggleRules(false));
                this.rulesContainer.add([bg, txt, closeBtn]);
            }

            createButton(x, y, text, color, callback) {
                const btn = this.add.text(x, y, text, {
                    fontFamily: 'Orbitron', fontSize: '30px', fontWeight: 'bold', color: '#ffffff',
                    backgroundColor: '#222222', padding: { x: 20, y: 10 }
                }).setOrigin(0.5).setInteractive();

                btn.on('pointerover', () => btn.setStyle({ fill: '#ffff00' }));
                btn.on('pointerout', () => btn.setStyle({ fill: '#ffffff' }));
                btn.on('pointerdown', callback);
            }

            toggleRules(show) { this.rulesContainer.setVisible(show); }
        }


        // --- SCENE 2: THE GAME ---
        class GameScene extends Phaser.Scene {
            constructor() { super({ key: 'GameScene' }); }

            init(data) { this.isSinglePlayer = data.isSinglePlayer || false; }

            create() {
                this.score1 = 0; this.score2 = 0; this.isGameOver = false;
                this.cursors = this.input.keyboard.createCursorKeys();

                this.generateTextures();
                this.particles = this.add.particles(0, 0, 'spark', {
                    speed: { min: 50, max: 150 }, scale: { start: 1, end: 0 },
                    blendMode: 'ADD', lifespan: 300, emitting: false
                });

                this.setupShips();
                this.setupAsteroids();
                this.setupCollisions();
                this.setupUI();

                this.input.on('pointerup', (pointer) => this.handleInput(pointer));

                if (this.isSinglePlayer) {
                    this.bot = new BotController(this, this.ship2, this.ship1, this.asteroids);
                    this.scoreText2.setText('CPU: 0');
                } else {
                    this.scoreText2.setText('P2: 0');
                }
            }

            update() {
                if (this.isGameOver) return;

                this.physics.world.wrap(this.ship1, 20);
                this.physics.world.wrap(this.ship2, 20);
                this.physics.world.wrap(this.asteroids, 60);

                if (this.isSinglePlayer && this.bot) {
                    this.bot.update();
                }

                // Keyboard for P1
                const IMPULSE = 300;
                if (this.cursors.left.isDown) this.ship1.setAccelerationX(-IMPULSE);
                else if (this.cursors.right.isDown) this.ship1.setAccelerationX(IMPULSE);
                else this.ship1.setAccelerationX(0);

                if (this.cursors.up.isDown) this.ship1.setAccelerationY(-IMPULSE);
                else if (this.cursors.down.isDown) this.ship1.setAccelerationY(IMPULSE);
                else this.ship1.setAccelerationY(0);
            }

            setupShips() {
                const p1StartX = ZONE_SIZE / 2;
                const p1StartY = this.scale.height - (ZONE_SIZE / 2);
                const p2StartX = this.scale.width - (ZONE_SIZE / 2);
                const p2StartY = ZONE_SIZE / 2;

                this.ship1 = this.physics.add.sprite(p1StartX, p1StartY, 'ship1_tex').setCircle(20);
                this.ship2 = this.physics.add.sprite(p2StartX, p2StartY, 'ship2_tex').setCircle(20);

                [this.ship1, this.ship2].forEach(s => {
                    s.setDamping(true); s.setDrag(0.5); s.setBounce(0.9); s.setMaxVelocity(400);
                });
            }

            setupAsteroids() {
                this.asteroids = this.physics.add.group({ classType: Asteroid, runChildUpdate: true });
                this.spawnEvent = this.time.addEvent({
                    delay: 2000, callback: this.spawnAsteroid, callbackScope: this, loop: true
                });
            }

            setupCollisions() {
                this.physics.add.collider(this.ship1, this.ship2, this.handlePvpCollision, null, this);
                this.physics.add.overlap(this.ship1, this.asteroids, (s, a) => this.collectAsteroid(s, a, 1), null, this);
                this.physics.add.overlap(this.ship2, this.asteroids, (s, a) => this.collectAsteroid(s, a, 2), null, this);
            }

            setupUI() {
                const zg = this.add.graphics();
                zg.lineStyle(2, 0x444444, 0.3);
                zg.strokeRect(0, this.scale.height - ZONE_SIZE, ZONE_SIZE, ZONE_SIZE);

                if (!this.isSinglePlayer) {
                    zg.strokeRect(this.scale.width - ZONE_SIZE, 0, ZONE_SIZE, ZONE_SIZE);
                }

                const fontStyle = { fontFamily: 'Orbitron', fontSize: '32px', fontWeight: 'bold' };
                this.scoreText1 = this.add.text(20, this.scale.height - 60, 'P1: 0', { ...fontStyle, color: '#ff0044' }).setDepth(100);
                this.scoreText2 = this.add.text(this.scale.width - 180, 30, 'P2: 0', { ...fontStyle, color: '#0088ff' }).setDepth(100);
            }

            handleInput(pointer) {
                if (this.isGameOver) return;
                const vectorX = pointer.upX - pointer.downX;
                const vectorY = pointer.upY - pointer.downY;
                if (Math.abs(vectorX) < 5 && Math.abs(vectorY) < 5) return;

                const IMPULSE_MULTIPLIER = 5;

                if (pointer.downX < ZONE_SIZE && pointer.downY > this.scale.height - ZONE_SIZE) {
                    this.ship1.setVelocity(this.ship1.body.velocity.x + (vectorX * IMPULSE_MULTIPLIER), this.ship1.body.velocity.y + (vectorY * IMPULSE_MULTIPLIER));
                }

                if (!this.isSinglePlayer) {
                    if (pointer.downX > this.scale.width - ZONE_SIZE && pointer.downY < ZONE_SIZE) {
                        this.ship2.setVelocity(this.ship2.body.velocity.x + (vectorX * IMPULSE_MULTIPLIER), this.ship2.body.velocity.y + (vectorY * IMPULSE_MULTIPLIER));
                    }
                }
            }

            spawnAsteroid() {
                if (this.isGameOver) return;
                const edge = Phaser.Math.Between(0, 3);
                let x, y;
                const buffer = 60;
                const w = this.scale.width, h = this.scale.height;
                if (edge === 0) { x = Phaser.Math.Between(0, w); y = -buffer; }
                else if (edge === 1) { x = w + buffer; y = Phaser.Math.Between(0, h); }
                else if (edge === 2) { x = Phaser.Math.Between(0, w); y = h + buffer; }
                else { x = -buffer; y = Phaser.Math.Between(0, h); }
                const asteroid = new Asteroid(this, x, y);
                this.asteroids.add(asteroid);
                asteroid.launch(this);
            }

            collectAsteroid(ship, asteroid, playerNum) {
                if (this.isGameOver) return;
                const points = asteroid.points;
                if (playerNum === 1) {
                    this.score1 += points;
                    this.scoreText1.setText('P1: ' + this.score1);
                } else {
                    this.score2 += points;
                    this.scoreText2.setText((this.isSinglePlayer ? 'CPU: ' : 'P2: ') + this.score2);
                }
                if (asteroid.growthTimer) asteroid.growthTimer.remove();
                asteroid.destroy();
                this.checkWin();
            }

            handlePvpCollision(s1, s2) {
                if (this.isGameOver) return;
                const speed1 = s1.body.speed;
                const speed2 = s2.body.speed;
                if (Math.abs(speed1 - speed2) < 2) return;

                this.cameras.main.shake(200, 0.01);
                this.particles.emitParticleAt((s1.x + s2.x) / 2, (s1.y + s2.y) / 2, 10);
                const REWARD = 3;

                if (speed1 > speed2) {
                    this.score2 += REWARD;
                    this.scoreText2.setText((this.isSinglePlayer ? 'CPU: ' : 'P2: ') + this.score2);
                    s2.setTint(0x00ff00); this.time.delayedCall(200, () => s2.clearTint());
                    this.showFloatingText(s2.x, s2.y, `+${REWARD}`, '#0088ff');
                    this.animateScoreGain(this.scoreText2);
                } else {
                    this.score1 += REWARD;
                    this.scoreText1.setText('P1: ' + this.score1);
                    s1.setTint(0x00ff00); this.time.delayedCall(200, () => s1.clearTint());
                    this.showFloatingText(s1.x, s1.y, `+${REWARD}`, '#ff0044');
                    this.animateScoreGain(this.scoreText1);
                }
                this.checkWin();
            }

            animateScoreGain(textObj) {
                this.tweens.add({ targets: textObj, scaleX: 1.5, scaleY: 1.5, duration: 100, yoyo: true, ease: 'Back.Out' });
            }

            showFloatingText(x, y, msg, color) {
                const txt = this.add.text(x, y, msg, { fontFamily: 'Orbitron', fontSize: '40px', fontWeight: 'bold', color: '#fff', stroke: color, strokeThickness: 4 }).setOrigin(0.5).setDepth(100);
                this.tweens.add({ targets: txt, y: y - 100, alpha: 0, duration: 1000, onComplete: () => txt.destroy() });
            }

            checkWin() {
                if (this.score1 >= WIN_SCORE || this.score2 >= WIN_SCORE) {
                    this.isGameOver = true;
                    this.physics.pause();
                    const overlay = this.add.rectangle(this.scale.width / 2, this.scale.height / 2, this.scale.width, this.scale.height, 0x000000, 0.8);
                    overlay.setDepth(200);

                    let winner = "";
                    if (this.score1 >= WIN_SCORE) winner = "PLAYER 1";
                    else winner = this.isSinglePlayer ? "CPU" : "PLAYER 2";

                    const color = this.score1 >= WIN_SCORE ? "#ff0044" : "#0088ff";
                    this.add.text(this.scale.width / 2, this.scale.height / 2 - 50, `${winner} WINS!`, {
                        fontFamily: 'Orbitron', fontSize: '50px', fontWeight: '900', color: color, stroke: '#ffffff', strokeThickness: 2
                    }).setOrigin(0.5).setDepth(201);

                    const btn = this.add.text(this.scale.width / 2, this.scale.height / 2 + 80, 'MAIN MENU', {
                        fontFamily: 'Orbitron', fontSize: '30px', backgroundColor: '#333', padding: { x: 20, y: 10 }
                    }).setOrigin(0.5).setDepth(201).setInteractive();

                    btn.on('pointerdown', () => this.scene.start('MainMenu'));
                }
            }

            generateTextures() {
                if (this.textures.exists('ship1_tex')) return;
                const g1 = this.make.graphics();
                g1.fillStyle(0xff0044); g1.fillEllipse(20, 20, 40, 40); g1.fillStyle(0xffffff); g1.fillCircle(20, 20, 12);
                g1.fillStyle(0xffff00);[[20, 5], [20, 35], [5, 20], [35, 20]].forEach(p => g1.fillCircle(p[0], p[1], 3));
                g1.generateTexture('ship1_tex', 40, 40);

                const g2 = this.make.graphics();
                g2.fillStyle(0x0088ff); g2.fillEllipse(20, 20, 40, 40); g2.fillStyle(0xffffff); g2.fillCircle(20, 20, 12);
                g2.fillStyle(0xffff00);[[20, 5], [20, 35], [5, 20], [35, 20]].forEach(p => g2.fillCircle(p[0], p[1], 3));
                g2.generateTexture('ship2_tex', 40, 40);

                [['asteroid_small', 0x888888, 12], ['asteroid_med', 0xaaaaaa, 22], ['asteroid_large', 0xcccccc, 45]].forEach(data => {
                    const g = this.make.graphics(); g.fillStyle(data[1]);
                    const points = [];
                    for (let i = 0; i < 8; i++) {
                        const a = (i / 8) * (Math.PI * 2); const r = data[2] * Phaser.Math.FloatBetween(0.8, 1.2);
                        points.push({ x: data[2] + Math.cos(a) * r, y: data[2] + Math.sin(a) * r });
                    }
                    g.fillPoints(points, true); g.generateTexture(data[0], data[2] * 2.5, data[2] * 2.5);
                });

                const gs = this.make.graphics(); gs.fillStyle(0xffffff); gs.fillCircle(4, 4, 4); gs.generateTexture('spark', 8, 8);
            }
        }

        class Asteroid extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, 'asteroid_small');
                scene.add.existing(this); scene.physics.add.existing(this);
                this.stage = 1; this.points = 1; this.body.setBounce(1); this.body.setCircle(12);
            }
            launch(scene) {
                const tx = Phaser.Math.Between(scene.scale.width * 0.2, scene.scale.width * 0.8);
                const ty = Phaser.Math.Between(scene.scale.height * 0.2, scene.scale.height * 0.8);
                const angle = Phaser.Math.Angle.Between(this.x, this.y, tx, ty);
                scene.physics.velocityFromRotation(angle, Phaser.Math.Between(50, 150), this.body.velocity);
                this.setAngularVelocity(Phaser.Math.Between(-20, 20));
                this.setNextGrowth(scene);
            }
            setNextGrowth(scene) {
                if (this.stage >= 3) return;
                this.growthTimer = scene.time.delayedCall(Phaser.Math.Between(4000, 8000), () => this.grow());
            }
            grow() {
                if (!this.scene) return;
                this.scene.tweens.add({
                    targets: this, scaleX: 0.1, scaleY: 0.1, duration: 200, ease: 'Back.In',
                    onComplete: () => {
                        if (!this.scene || !this.active) return;
                        this.stage++;
                        if (this.stage === 2) { this.setTexture('asteroid_med'); this.body.setCircle(22); this.points = 2; }
                        else if (this.stage === 3) { this.setTexture('asteroid_large'); this.body.setCircle(45); this.points = 5; }
                        this.scene.tweens.add({ targets: this, scaleX: 1, scaleY: 1, duration: 400, ease: 'Back.Out' });
                        this.setNextGrowth(this.scene);
                    }
                });
            }
        }

        const config = {
            type: Phaser.AUTO,
            // FIXED 9:16 RESOLUTION
            // Guaranteed to look the same on all devices.
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: LOGICAL_WIDTH,
                height: LOGICAL_HEIGHT
            },
            backgroundColor: '#000000', pixelArt: true,
            physics: { default: 'arcade', arcade: { gravity: { x: 0, y: 0 }, debug: false } },
            scene: [MainMenu, GameScene]
        };

        const game = new Phaser.Game(config);
    </script>

</body>

</html>