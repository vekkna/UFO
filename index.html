<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>UFO Prototype - Round Ships & Keyboard</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            display: block;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>

<body>

    <script>
        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: '#1a1a1a',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { x: 0, y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        let ship1, ship2;
        let cursors; // Keyboard input
        const IMPULSE_MULTIPLIER = 4;
        const KEYBOARD_IMPULSE = 300; // Fixed strength for arrow keys
        const ZONE_SIZE = 250;

        function preload() {
            // No assets needed
        }

        function create() {
            this.input.addPointer(2);

            // --- KEYBOARD SETUP ---
            cursors = this.input.keyboard.createCursorKeys();

            // --- GRAPHICS: ROUND UFOS ---

            // Ship 1 Texture (Red UFO)
            const g1 = this.make.graphics();
            g1.fillStyle(0xff4444);
            g1.fillCircle(20, 20, 20); // Base
            g1.fillStyle(0xffcccc);
            g1.fillCircle(20, 20, 8);  // Cockpit
            g1.generateTexture('ship1_tex', 40, 40);

            // Ship 2 Texture (Blue UFO)
            const g2 = this.make.graphics();
            g2.fillStyle(0x4444ff);
            g2.fillCircle(20, 20, 20); // Base
            g2.fillStyle(0xccccff);
            g2.fillCircle(20, 20, 8);  // Cockpit
            g2.generateTexture('ship2_tex', 40, 40);

            // --- SETUP OBJECTS ---

            const p1StartX = ZONE_SIZE / 2;
            const p1StartY = this.scale.height - (ZONE_SIZE / 2);
            const p2StartX = this.scale.width - (ZONE_SIZE / 2);
            const p2StartY = ZONE_SIZE / 2;

            ship1 = this.physics.add.sprite(p1StartX, p1StartY, 'ship1_tex');
            ship2 = this.physics.add.sprite(p2StartX, p2StartY, 'ship2_tex');

            // Use circle collision bodies for better bouncing
            ship1.setCircle(20);
            ship2.setCircle(20);

            // --- PHYSICS (ZERO FRICTION) ---
            ship1.setDamping(false).setDrag(0).setBounce(0.9).setMaxVelocity(600);
            ship2.setDamping(false).setDrag(0).setBounce(0.9).setMaxVelocity(600);

            this.physics.add.collider(ship1, ship2);

            // --- VISUAL DEBUG ZONES ---
            const zoneGraphics = this.add.graphics();
            zoneGraphics.lineStyle(2, 0x00ff00, 0.5);
            zoneGraphics.strokeRect(0, this.scale.height - ZONE_SIZE, ZONE_SIZE, ZONE_SIZE);
            zoneGraphics.strokeRect(this.scale.width - ZONE_SIZE, 0, ZONE_SIZE, ZONE_SIZE);

            // --- TOUCH INPUT LOGIC ---
            this.input.on('pointerup', (pointer) => {
                const vectorX = pointer.upX - pointer.downX;
                const vectorY = pointer.upY - pointer.downY;

                if (Math.abs(vectorX) < 5 && Math.abs(vectorY) < 5) return;

                // Player 1 (Bottom Left)
                if (pointer.downX < ZONE_SIZE && pointer.downY > this.scale.height - ZONE_SIZE) {
                    ship1.setVelocity(ship1.body.velocity.x + (vectorX * IMPULSE_MULTIPLIER), ship1.body.velocity.y + (vectorY * IMPULSE_MULTIPLIER));
                }

                // Player 2 (Top Right)
                else if (pointer.downX > this.scale.width - ZONE_SIZE && pointer.downY < ZONE_SIZE) {
                    ship2.setVelocity(ship2.body.velocity.x + (vectorX * IMPULSE_MULTIPLIER), ship2.body.velocity.y + (vectorY * IMPULSE_MULTIPLIER));
                }
            });
        }

        function update() {
            this.physics.world.wrap(ship1, 20);
            this.physics.world.wrap(ship2, 20);

            // --- KEYBOARD TESTING LOGIC (For Player 1) ---
            // We use JustDown so it acts like a single "Kick" rather than a rocket thruster

            if (Phaser.Input.Keyboard.JustDown(cursors.left)) {
                ship1.setVelocityX(ship1.body.velocity.x - KEYBOARD_IMPULSE);
            }
            else if (Phaser.Input.Keyboard.JustDown(cursors.right)) {
                ship1.setVelocityX(ship1.body.velocity.x + KEYBOARD_IMPULSE);
            }

            if (Phaser.Input.Keyboard.JustDown(cursors.up)) {
                ship1.setVelocityY(ship1.body.velocity.y - KEYBOARD_IMPULSE);
            }
            else if (Phaser.Input.Keyboard.JustDown(cursors.down)) {
                ship1.setVelocityY(ship1.body.velocity.y + KEYBOARD_IMPULSE);
            }
        }
    </script>

</body>

</html>